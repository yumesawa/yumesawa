<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大文件上传与下载解决方案</title>
      <link href="/2019/11/26/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/11/26/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h2><p>基于 <a href="https://github.com/simple-uploader/Uploader" target="_blank" rel="noopener">simple-uploader.js</a>的vue插件<a href="https://github.com/simple-uploader/vue-uploader" target="_blank" rel="noopener">vue-simple-uploader</a> 实现分片上传。</p><p><strong>分片上传</strong>，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part）来进行分别上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。分片上传不仅可以避免因网络环境不好导致的一直需要从文件起始位置还是上传的问题，还能使用多线程对不同分块数据进行并发发送，提高发送效率，降低发送时间。</p><p>分片上传的整个流程大致如下：</p><ol><li><p>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</p></li><li><p>初始化一个分片上传任务，返回本次分片上传唯一标识；</p></li><li><p>按照一定的策略（串行或并行）发送各个分片数据块；</p></li><li><p>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。</p></li></ol><p>在整个数据上传的过程中当然还涉及数据的签名校验，防止数据被恶意篡改。<br>整个上传流程图如下所示 ：</p><p>关于<a href="https://github.com/simple-uploader/vue-uploader" target="_blank" rel="noopener">vue-simple-uploader</a> </p><p>在日常开发中经常会遇到文件上传的需求，<a href="https://github.com/simple-uploader/vue-uploader" target="_blank" rel="noopener">vue-simple-uploader</a> 就是一个基于 <a href="https://github.com/simple-uploader/Uploader" target="_blank" rel="noopener">simple-uploader.js</a> 和 Vue 结合做的一个上传组件，自带 UI，可覆盖、自定义；</p><p>其主要特点就是：</p><ul><li><p>支持文件、多文件、文件夹上传-</p></li><li><p>支持拖拽文件、文件夹上传</p></li><li><p>统一对待文件和文件夹，方便操作管理</p></li><li><p>可暂停、继续上传</p></li><li><p>错误处理</p></li><li><p>支持“快传”，通过文件判断服务端是否已存在从而实现“快传”</p></li><li><p>上传队列管理，支持最大并发上传</p></li><li><p>分块上传</p></li><li><p>支持进度、预估剩余时间、出错自动重试、重传等操作</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过<code>npm</code>安装：<code>npm install vue-simple-uploader --save</code>即可。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="在main-js中初始化"><a href="#在main-js中初始化" class="headerlink" title="在main.js中初始化"></a>在main.js中初始化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> uploader <span class="keyword">from</span> <span class="string">'vue-simple-uploader'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(uploader)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render(createElement) &#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(App)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>新建一个vue组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;uploader :options=&quot;options&quot; class=&quot;uploader-example&quot;&gt;</span><br><span class="line">      &lt;uploader-unsupport&gt;&lt;/uploader-unsupport&gt;</span><br><span class="line">      &lt;uploader-drop&gt;</span><br><span class="line">        &lt;p&gt;Drop files here to upload or&lt;/p&gt;</span><br><span class="line">        &lt;uploader-btn&gt;select files&lt;/uploader-btn&gt;</span><br><span class="line">        &lt;uploader-btn :attrs=&quot;attrs&quot;&gt;select images&lt;/uploader-btn&gt;</span><br><span class="line">        &lt;uploader-btn :directory=&quot;true&quot;&gt;select folder&lt;/uploader-btn&gt;</span><br><span class="line">      &lt;/uploader-drop&gt;</span><br><span class="line">      &lt;uploader-list&gt;&lt;/uploader-list&gt;</span><br><span class="line">    &lt;/uploader&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name:&apos;Upload&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        // https://github.com/simple-uploader/Uploader/tree/develop/samples/Node.js</span><br><span class="line">        target: this.$api+&apos;api/user/upload/&apos;,</span><br><span class="line">        testChunks: false,</span><br><span class="line">        chunkSize: &apos;2048000&apos; </span><br><span class="line">      &#125;,</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        accept: &apos;image/*&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.uploader-example &#123;</span><br><span class="line">  width: 880px;</span><br><span class="line">  padding: 15px;</span><br><span class="line">  margin: 40px auto 0;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">  box-shadow: 0 0 10px rgba(0, 0, 0, .4);</span><br><span class="line">&#125;</span><br><span class="line">.uploader-example .uploader-btn &#123;</span><br><span class="line">  margin-right: 4px;</span><br><span class="line">&#125;</span><br><span class="line">.uploader-example .uploader-list &#123;</span><br><span class="line">  max-height: 440px;</span><br><span class="line">  overflow: auto;</span><br><span class="line">  overflow-x: hidden;</span><br><span class="line">  overflow-y: auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="后端思路："><a href="#后端思路：" class="headerlink" title="后端思路："></a>后端思路：</h4><p>为每个分片创建一个新的临时文件来保存其内容；待全部分片上传完毕后，再按顺序读取所有临时文件的内容，将数据写入新文件中。</p><p>在前端给我们的中不止含有文件，还有如下参数：</p><ul><li><code>chunkNumber</code>: 当前块的次序，第一个块是 1，注意不是从 0 开始的。</li><li><code>totalChunks</code>: 文件被分成块的总数。</li><li><code>chunkSize</code>: 分块大小，根据 <code>totalSize</code> 和这个值你就可以计算出总共的块数。注意最后一块的大小可能会比这个要大。</li><li><code>currentChunkSize</code>: 当前块的大小，实际大小。</li><li><code>totalSize</code>: 文件总大小。</li><li><code>identifier</code>: 这个就是每个文件的唯一标示。</li><li><code>filename</code>: 文件名。</li><li><code>relativePath</code>: 文件夹上传的时候文件的相对路径属性。</li></ul><p>我们可以根据文件的唯一标识+当前块数来命名保存一个临时文件，然后进行拼接。</p><p>我们在保存临时文件时，由于vue给我们发过来的是异步请求，本来要求请求马上出现,是异步会导致后面突然再执行。</p><p>这时会报一个：<strong>self._sock.sendall(b) ConnectionAbortedError: [WinError 10053]</strong> <strong>您的主机中的软件中止了一个已建立的连接。</strong>的错误</p><p>有<strong>两种解决方案</strong>：</p><p>在ajax进行异步提交时，将async 改为 false 即可，但是由于vue给我们发的是axios请求，所以并不适用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;  </span><br><span class="line">        type : <span class="string">"post"</span>,  </span><br><span class="line">        url : <span class="string">"**************"</span>,  </span><br><span class="line">        data : data,  </span><br><span class="line">        <span class="keyword">async</span> : <span class="literal">false</span>,  </span><br><span class="line">        success : <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;  </span><br><span class="line">          alert(data)  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>所以我们依赖第二种方案：</p><p>找到你python/lib/socketserver.py文件775行，修改SocketWriter类的write方法，具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, b)</span>:</span></span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">          self._sock.sendall(b)</span><br><span class="line">      <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        self._sock.close()</span><br><span class="line">      <span class="keyword">with</span> memoryview(b) <span class="keyword">as</span> view:</span><br><span class="line">          <span class="keyword">return</span> view.nbytes</span><br></pre></td></tr></table></figure><p>这时临时文件已经进行保存，全部保存成功后，<a href="https://github.com/simple-uploader/vue-uploader" target="_blank" rel="noopener">vue-simple-uploader</a> 会给我们一个回调，我们可以在vue中得到这个回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;uploader :options=&quot;options&quot; class=&quot;uploader-example&quot; @file-success=&quot;fileSuccess&quot;&gt; #得到文件上传成功指定一个函数方法</span><br><span class="line">  &lt;uploader-unsupport&gt;&lt;/uploader-unsupport&gt;</span><br><span class="line">  &lt;uploader-drop&gt;</span><br><span class="line">    &lt;p&gt;Drop files here to upload or&lt;/p&gt;</span><br><span class="line">    &lt;uploader-btn v-on:finish=&quot;fileSuccess&quot;&gt;select files&lt;/uploader-btn&gt;</span><br><span class="line">    &lt;uploader-btn :attrs=&quot;attrs&quot;&gt;select images&lt;/uploader-btn&gt;</span><br><span class="line">    &lt;uploader-btn :directory=&quot;true&quot;&gt;select folder&lt;/uploader-btn&gt;</span><br><span class="line">  &lt;/uploader-drop&gt;</span><br><span class="line">  &lt;uploader-list&gt;&lt;/uploader-list&gt;</span><br><span class="line">&lt;/uploader&gt;</span><br></pre></td></tr></table></figure><p>此时这个函数会有如下参数：</p><p><code>fileSuccess(rootFile, file, message, chunk)</code>一个文件上传成功事件</p><p>第一个参数<code>rootFile</code>就是成功上传的文件所属的根<code>Uploader.File</code>对象，它应该包含或者等于成功上传文件；</p><p>第二个参数<code>file</code>就是当前成功的<code>Uploader.File</code>对象本身；</p><p>第三个参数就是<code>message</code>就是服务端响应内容，永远都是字符串；</p><p>第四个参数<code>chunk</code>就是<code>Uploader.Chunk</code>实例，它就是该文件的最后一个块实例，如果你想得到请求响应码的话，<code>chunk.xhr.status</code> 就是。</p><p>我们可以根据message返回的状态码来判断文件是否上传成功（注意转JSON），从而发起一个axios请求，进行文件拼接，此时临时文件上传与文件拼接是原子性的。我们可以把上传成功文件的唯一标识以及文件名称发给后端</p><p>我们可以在后端以wb方式打开一个文件，此时的文件就是前端发给我们的文件名，然后根据文件唯一标识去遍历临时文件，依次写入，然后删除临时文件</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">chunk=<span class="number">1</span></span><br><span class="line">      <span class="keyword">with</span> open(<span class="string">'static/media/'</span>+request.data[<span class="string">'filename'</span>],<span class="string">'wb'</span>) <span class="keyword">as</span> tar_file:</span><br><span class="line">          <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">              <span class="keyword">try</span>:</span><br><span class="line">                  filename = <span class="string">'static/media/'</span>+request.data[<span class="string">'uniquefile'</span>]+str(chunk)</span><br><span class="line">                  tem_file=open(filename,<span class="string">'rb'</span>)</span><br><span class="line">                  tar_file.write(tem_file.read())</span><br><span class="line">                  tem_file.close()</span><br><span class="line">              <span class="keyword">except</span> IOError:</span><br><span class="line">                  <span class="keyword">break</span></span><br><span class="line">              chunk+=<span class="number">1</span></span><br><span class="line">              os.remove(filename)</span><br><span class="line">      <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>:<span class="number">200</span>&#125;)</span><br></pre></td></tr></table></figure><p>此时一个大文件的上传并写入操作以及完成了！</p><p>附上git：<a href="https://gitee.com/likezx/upload_vue.git" target="_blank" rel="noopener">https://gitee.com/likezx/upload_vue.git</a></p><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p>为了避免客户端在下载之后的进度数据被删除而导致重新开始从头下载的问题，服务端也可以提供相应的接口便于客户端对已经下载的分片数据进行查询，从而使客户端知道已经下载的分片数据，从而从下一个分片数据开始继续下载。</p><p>所谓断点续传，前提是上传文件为大文件，如果文件较小，则体现不出断点续传的优势。</p><p><strong>断点续传大文件的优势：</strong></p><ol><li><p>文件上传过程中上传了一半，网络中断，再次上传可以从上次中断处开始上传，节省带宽和上传时间。</p></li><li><p>由于断点续传需要验证文件的hash，可以避免相同文件多次上传，节约服务器存储空间，节约用户操作时间，加上友好提示，可以提高用户的体验度。</p></li></ol><p><strong>要实现HTTP断点续传必须要简单了解以下几个报文：</strong></p><ul><li>Accept-Ranges： 告诉客户端(浏览器..)服务器端支持断点续传 服务器端返回</li><li>Range：客户端告诉服务器端从指定的的位置/范围(这里值字节数)下载资源 客户端发出</li><li>Content-Range： 服务器端告诉客户端响应的数据信息，在整个返回体中本部分的字节位置 服务器端返回</li><li>ETag： 资源标识 非必须 服务器端返回</li><li>Last-Modified： 资源最后一次更新的时间 非必须 服务器端返回</li></ul><p><strong>Range</strong> <strong>的范围格式：</strong></p><ol><li><p>表示0-499个字节范围：Range: bytes=0-499</p></li><li><p>表示最后500个字节范围：Range: bytes=-500</p></li><li><p>表示500字节开始到结束范围：Range: bytes=500-</p></li><li><p>表示第一个和最后一个字节：Range: bytes=0-0,-1</p></li><li><p>表示同时指定几个范围：Range: bytes=500-600,601-999</p></li></ol><p><strong>Content-Range</strong> <strong>的数据格式：</strong></p><p>Content-Range: bytes 0-499/22036 ：表示返回0-499字节范围数据 资源一共22036个字节</p><p><strong>原理：</strong></p><ol><li><p>客户端发起请求 设置Range指定开始字节数或结束字节数 如果是从0开始也可以不用设置。</p></li><li><p>服务器端检查到客户端Range头 解析开始字节数以及结束字节数 并返回报文头 Accept-Ranges表示支持断点续传，Content-Range记录该次向客户端写入流的位置信息，然后再写入流到客户端。</p></li><li><p>服务端可以使用ETag Last-Modified 标记一下资源是否被修改。作一些验证工作，如果验证不通过则返回错误，非必须项。</p></li></ol><p><strong>实现方式：</strong></p><p>功能基于django.views.static.serve实现，实现的关键点是：</p><ol><li><p>response中增加’Content-Range’、’Cache-Control’的参数</p></li><li><p>根据不同的情况为response设置不同的status</p></li><li><p>根据HTTP_RANGE对读取文件时的起始位置进行设置</p></li></ol><p><strong>视图函数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载断点续传</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownlaodFile</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request, md5)</span>:</span></span><br><span class="line">        <span class="comment"># 需要get方式传来一个文件的md5值</span></span><br><span class="line">     file = models.File.objects.filter(md5=md5).first()</span><br><span class="line">        <span class="comment"># 根据该md5值到数据库中查找文件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> file:</span><br><span class="line">            <span class="keyword">raise</span> Http404</span><br><span class="line">        statobj = os.stat(file.address)</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        print(statobj)后得到：</span></span><br><span class="line"><span class="string">        os.stat_result(st_mode=33188, st_ino=1061429, st_dev=64769,</span></span><br><span class="line"><span class="string">        st_nlink=1, st_uid=0, st_gid=0, st_size=454004, st_atime=1577018223,</span></span><br><span class="line"><span class="string">        st_mtime=1572833320, st_ctime=1572833320)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断下载过程中文件是否被修改过</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> was_modified_since(</span><br><span class="line">            request.META.get(<span class="string">'HTTP_IF_MODIFIED_SINCE'</span>),</span><br><span class="line">            statobj.st_mtime, statobj.st_size</span><br><span class="line">        ):</span><br><span class="line">            <span class="keyword">return</span> HttpResponseNotModified()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取文件的content_type</span></span><br><span class="line">        content_type, encoding = mimetypes.guess_type(file.address)</span><br><span class="line">        content_type = content_type <span class="keyword">or</span> <span class="string">'application/octet-stream'</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 文件起点位置</span></span><br><span class="line">        start_bytes = re.search(</span><br><span class="line">            <span class="string">r'bytes=(\d+)-'</span>, </span><br><span class="line">            request.META.get(<span class="string">'HTTP_RANGE'</span>, <span class="string">''</span>),</span><br><span class="line">            re.S</span><br><span class="line">        )</span><br><span class="line">        start_bytes = int(start_bytes.group(<span class="number">1</span>)) <span class="keyword">if</span> start_bytes <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 移动文件至上次下载位置</span></span><br><span class="line">        the_file = open(file.address, <span class="string">'rb'</span>)</span><br><span class="line">        the_file.seek(start_bytes, os.SEEK_SET)</span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        status=200表示下载开始，status=206表示下载暂停后继续，为了兼容火狐浏览器而区分两种状态</span></span><br><span class="line"><span class="string">        关于django的response对象，参考：https://www.cnblogs.com/scolia/p/5635546.html</span></span><br><span class="line"><span class="string">        关于response的状态码，参考：https://www.cnblogs.com/DeasonGuan/articles/Hanami.html</span></span><br><span class="line"><span class="string">        FileResponse默认block_size = 4096，因此迭代器每次读取4KB数据</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        response = FileResponse(</span><br><span class="line">            the_file,</span><br><span class="line">            content_type = file.mimeType <span class="keyword">or</span> <span class="string">'application/octet-stream'</span>,</span><br><span class="line">            status = <span class="number">206</span> <span class="keyword">if</span> start_bytes &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">200</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 文件修改时间</span></span><br><span class="line">        response[<span class="string">'Last-Modified'</span>] = http_date(statobj.st_mtime)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里'Content-Length'表示剩余待传输的文件字节长度</span></span><br><span class="line">        <span class="keyword">if</span> stat.S_ISREG(statobj.st_mode):</span><br><span class="line">            response[<span class="string">'Content-Length'</span>] = statobj.st_size - start_bytes</span><br><span class="line">        </span><br><span class="line">        response[<span class="string">'Content-Range'</span>] = <span class="string">'bytes %s-%s/%s'</span> % (</span><br><span class="line">            start_bytes,   <span class="comment"># 起点</span></span><br><span class="line">            statobj.st_size - <span class="number">1</span>, </span><br><span class="line">            statobj.st_size</span><br><span class="line">        )</span><br><span class="line">        response[<span class="string">'Cache-Control'</span>] = <span class="string">'no-cache, no-store, must-revalidate'</span></span><br><span class="line">        <span class="keyword">return</span>  response</span><br></pre></td></tr></table></figure><p>例子：<a href="https://gitee.com/yumesawa/project.git" target="_blank" rel="noopener">https://gitee.com/yumesawa/project.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 业务场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django&amp;Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx防盗链配置</title>
      <link href="/2019/09/25/Nginx%E9%98%B2%E7%9B%97%E9%93%BE%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/09/25/Nginx%E9%98%B2%E7%9B%97%E9%93%BE%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx防盗链配置案例配置"><a href="#Nginx防盗链配置案例配置" class="headerlink" title="Nginx防盗链配置案例配置"></a>Nginx防盗链配置案例配置</h2><p>防盗链的含义是网站内容本身不在自己公司的服务器上，而通过技术手段，直接在调用其他公司的服务器网站数据，而向最终用户提供此内容。</p><p>一些小网站盗链高访问量网站的音乐、图片、软件的链接，然后放置在自己的网站中，通过这种方法盗取高访问量网站的空间和流量。</p><p>网站每天访问量很大，而且占用了很多不必要的带宽，浪费资源，所以必须采取一些限制措施。</p><p>防盗链其实就是采用服务器端编程技术，通过URL过滤、主机名等实现的防止盗链的软件。</p><p>例如<a href="http://www.jfedu.net/linux/页面，如果没有配置防盗链，别人就能轻而易举的在其的网站上引用该页面。" target="_blank" rel="noopener">http://www.jfedu.net/linux/页面，如果没有配置防盗链，别人就能轻而易举的在其的网站上引用该页面。</a></p><h3 id="Nginx防盗链配置代码如下："><a href="#Nginx防盗链配置代码如下：" class="headerlink" title="Nginx防盗链配置代码如下："></a>Nginx防盗链配置代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80；</span><br><span class="line">        server_name  jfedu.net www.jfedu.net；</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/b；</span><br><span class="line">            index  index.html index.htm；</span><br><span class="line">        &#125;</span><br><span class="line">        location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">                valid_referers none blocked  jfedu.net  *.jfedu.net；</span><br><span class="line">                root   html/b；</span><br><span class="line">            if ($invalid_referer) &#123;</span><br><span class="line">                    #rewrite ^/ http://www.jfedu.net/403.html；</span><br><span class="line">                    return 403；</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx防盗链参数详解："><a href="#Nginx防盗链参数详解：" class="headerlink" title="Nginx防盗链参数详解："></a>Nginx防盗链参数详解：</h3><ul><li><p><strong>valid_referers表示可用的referers设置</strong></p></li><li><p><strong>none 表示没有referers，直接通过浏览器或者其他工具访问。</strong></p></li><li><p><strong>blocked表示有referers，但是被代理服务器或者防火墙隐藏；</strong></p></li><li><p><strong>jfedu.net 表示通过jfedu.net访问的referers；</strong></p></li><li><p><strong>*.jfedu.net 表示通过*.jfedu.net访问的referers</strong></p></li><li><p><strong>*表示任意host主机。</strong></p></li></ul><h3 id="除了以上方法，按照如下方法设置也可以实现防盗链："><a href="#除了以上方法，按照如下方法设置也可以实现防盗链：" class="headerlink" title="除了以上方法，按照如下方法设置也可以实现防盗链："></a>除了以上方法，按照如下方法设置也可以实现防盗链：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|png|swf|flv)$</span><br><span class="line">if ($host !=’*.jfedu.net’) &#123;</span><br><span class="line">    return 403；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx下载安装</title>
      <link href="/2019/06/11/Nginx%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/"/>
      <url>/2019/06/11/Nginx%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="下载Nginx安装包"><a href="#下载Nginx安装包" class="headerlink" title="下载Nginx安装包"></a>下载Nginx安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.16.1.tar.gz</span><br><span class="line"># 此时下载的是官方发布的稳定版</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz       # zxvf解压gz属性的压缩包</span><br></pre></td></tr></table></figure><h2 id="进入nginx目录"><a href="#进入nginx目录" class="headerlink" title="进入nginx目录"></a>进入nginx目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.16.1</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd到刚才配置的安装目录/usr/loca/nginx/</span><br><span class="line">./sbin/nginx -t</span><br></pre></td></tr></table></figure><h2 id="开启80端口："><a href="#开启80端口：" class="headerlink" title="开启80端口："></a>开启80端口：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line">--permanent   #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure><h2 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure><h2 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx //启动nginx</span><br></pre></td></tr></table></figure><h2 id="配置nginx开机自启动"><a href="#配置nginx开机自启动" class="headerlink" title="配置nginx开机自启动"></a>配置nginx开机自启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove nginx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/2019/05/12/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/05/12/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Reids主从"><a href="#Reids主从" class="headerlink" title="Reids主从"></a>Reids主从</h2><blockquote><p>​    主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。</p><p>​    默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p></blockquote><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ol><li><p><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p></li><li><p><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p></li><li><p><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p></li><li><p><strong>高可用基石：</strong> 主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p></li></ol><h3 id="主从拓扑结构"><a href="#主从拓扑结构" class="headerlink" title="主从拓扑结构"></a>主从拓扑结构</h3><p>​    <strong>一主一从：</strong></p><p>用于主节点故障转移从节点，当主节点的“写”命令并发高且需要持久化，可以只在从节点开启AOF（主节点不需要），这样即保证了数据的安全性，也避免持久化对主节点的影响。 </p><p>​    <strong>一主多从：</strong></p><p>　　这一结构主要针对“读”较多的场景，“读”由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定。</p><p>​    <strong>树状主从:</strong></p><p>　　这一结构是对一主多从的补充，主节点只推送一次数据到slave1和slave2，再由从slave2推送到slave3和 slave4，减轻主节点推送的压力。</p><h2 id="主从复制的实现原理"><a href="#主从复制的实现原理" class="headerlink" title="主从复制的实现原理"></a>主从复制的实现原理</h2><p>主从复制过程大体可以分为3个阶段：<strong>连接建立阶段（即准备阶段）</strong>、<strong>数据同步阶段</strong>、<strong>命令传播阶段</strong>；</p><h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><h4 id="step1：保存主节点信息"><a href="#step1：保存主节点信息" class="headerlink" title="step1：保存主节点信息"></a>step1：保存主节点信息</h4><p>​    从节点服务器内部维护了两个字段，即<strong>masterhost</strong>和<strong>masterport</strong>字段，用于存储主节点的<strong>ip</strong>和<strong>port</strong>信息。</p><p>​    <strong>slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</strong></p><h4 id="step2：建立socket连接"><a href="#step2：建立socket连接" class="headerlink" title="step2：建立socket连接"></a>step2：建立socket连接</h4><p>​    <strong>从节点每秒1次调用复制定时函数replicationCron()</strong>，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。</p><p><strong>如果连接成功：</strong></p><p>​    <strong>从节点：</strong> 为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p><p>​    <strong>主节点：</strong> 接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</p><h4 id="step3：发送ping命令"><a href="#step3：发送ping命令" class="headerlink" title="step3：发送ping命令"></a>step3：发送ping命令</h4><p>​    从节点成为主节点的客户端之后，发送ping命令进行首次请求，<strong>目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</strong></p><p><strong>从节点发送ping命令后，可能出现3种情况：</strong></p><ol><li><p>返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p></li><li><p>超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p></li><li><p>返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p></li></ol><h4 id="step4：身份验证"><a href="#step4：身份验证" class="headerlink" title="step4：身份验证"></a>step4：身份验证</h4><p>如果从节点中设置了<strong>masterauth</strong>选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。</p><p>从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p><p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p><h4 id="step5：发送从节点端口信息"><a href="#step5：发送从节点端口信息" class="headerlink" title="step5：发送从节点端口信息"></a>step5：发送从节点端口信息</h4><p>身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；<strong>该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</strong></p><h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p><p>具体执行的方式是：从节点向主节点发送<strong>psync命令</strong>，开始同步。</p><p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制和部分复制</strong>。</p><blockquote><p>在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p></blockquote><h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>​    数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p><p>​    在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。</p><p><strong>PS：</strong></p><p>​    <strong>延迟与不一致：</strong> 命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p><p>​    <strong>repl-disable-tcp-nodelay no：</strong> 该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p><h3 id="【数据同步阶段】全量复制和部分复制"><a href="#【数据同步阶段】全量复制和部分复制" class="headerlink" title="【数据同步阶段】全量复制和部分复制"></a>【数据同步阶段】全量复制和部分复制</h3><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；</p><p>在Redis2.8以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p><ol><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ol><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><strong>Redis通过psync命令进行全量复制的过程如下：</strong></p><ol><li><p>从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；</p></li><li><p>主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</p></li><li><p>主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。</p></li><li><p>主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</p></li><li><p>如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。</p></li></ol><p><strong>通过全量复制的过程可以看出，全量复制是非常重型的操作：</strong></p><ol><li><p>主节点通过<strong>bgsave</strong>命令<strong>fork</strong>子进程进行<strong>RDB</strong>持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；</p></li><li><p>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗。</p></li><li><p>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗。</p></li></ol><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>​    由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p><p>​    部分复制的实现，依赖于三个重要的概念：复制偏移量，复制积压缓冲区，服务器运行ID</p><h5 id="offset-复制偏移量"><a href="#offset-复制偏移量" class="headerlink" title="offset 复制偏移量"></a>offset 复制偏移量</h5><p>​        在主从复制的Master(主节点)和Slave(从节点)双方都会各自维持一个offset，代表的是<strong>主节点向从节点传递的字节数</strong>；Master成功发送N个字节的命令后会将Master的offset加上N，Slave在接收到N个字节命令后同样会将Slave的offset增加N。Master和Slave如果状态是一致的那么它的的offset也应该是一致的。</p><p>​        offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p><h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>  复制积压缓冲区是由<strong>Master(主节点)维护的一个固定长度的FIFO队列(先进先出)</strong>，默认大小1MB；当主节点开始有从节点时创建，它的作用是缓存已经传播出去的命令。当Master进行命令传播时，不仅将命令发送给所有Slave，还会将命令写入到复制积压缓冲区里面。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p><p>​        除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p><p>​        由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><p><strong>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</strong></p><ul><li><strong>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</strong></li><li><strong>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</strong></li></ul><h5 id="runid-服务器运行ID"><a href="#runid-服务器运行ID" class="headerlink" title="runid 服务器运行ID"></a>runid 服务器运行ID</h5><p>​        每个Redis服务器(无论主从)在启动时都会自动生成一个表明自己身份的随机ID(每次启动都不一样)，由40个随机的十六进制字符组成。在PSYNC中发送的这个ID是指之前连接的Master的ID，如果没保存这个ID，PSYNC命令会使用 <strong>”PSYNC ? -1”</strong>  这种形式发送给Master，表示需要全量复制。</p><p>​        每个Redis节点，在启动时都会自动生成一个随机ID，由40个随机的十六进制字符组成；</p><p>runid用来唯一识别一个Redis节点。<strong>通过info Server命令，可以查看节点的runid。</strong></p><p>​        主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；</p><p><strong>主节点根据runid判断能否进行部分复制：</strong></p><ul><li><p>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p></li><li><p>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</p></li></ul><h3 id="PSYNC命令"><a href="#PSYNC命令" class="headerlink" title="PSYNC命令"></a>PSYNC命令</h3><p>  Redis在2.8版本提供了PSYNC命令来带代替SYNC命令，为Redis主从复制提供了部分复制的能力。</p><h4 id="PSYNC命令格式"><a href="#PSYNC命令格式" class="headerlink" title="PSYNC命令格式"></a>PSYNC命令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PSYNC &lt;runid&gt; &lt;offset&gt;</span><br><span class="line"># runid:主服务器ID</span><br><span class="line"># offset:从服务器最后接收命令的偏移量</span><br></pre></td></tr></table></figure><p>  <strong>PSYNC执行过程中比较重要的概念有3个：runid、offset（复制偏移量）以及复制积压缓冲区。</strong></p><h4 id="psync命令的执行"><a href="#psync命令的执行" class="headerlink" title="psync命令的执行"></a>psync命令的执行</h4><ol><li><p>首先从节点根据当前状态，决定如何调用psync命令：</p><ul><li>如果从节点之前未执行过<strong>slaveof</strong>或最近执行了<strong>slaveof no one</strong>，则从节点发送命令为<strong>psync ? -1</strong>，向主节点请求全量复制；</li><li>如果从节点之前执行了 <strong>slaveof</strong>，则发送命令为 <strong>psync <runid> <offset></strong> ，其中 <strong>runid</strong> 为上次复制的主节点的 <strong>runid</strong> ，<strong>offset</strong> 为上次复制截止时从节点保存的复制偏移量。</li></ul></li><li><p>主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：</p><ul><li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；</li><li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li><li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复 <strong>+FULLRESYNC <runid> <offset></strong> ，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</li></ul></li></ol><h3 id="【命令传播阶段】心跳机制"><a href="#【命令传播阶段】心跳机制" class="headerlink" title="【命令传播阶段】心跳机制"></a>【命令传播阶段】心跳机制</h3><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p><h4 id="主-gt-从：PING"><a href="#主-gt-从：PING" class="headerlink" title="主-&gt;从：PING"></a>主-&gt;从：PING</h4><p>每隔指定的时间，<strong>主节点会向从节点发送PING命令</strong>，这个PING命令的作用，主要是为了让从节点进行超时判断。</p><p>PING发送的频率由 repl-ping-slave-period 参数控制，单位是秒，默认值是10s。</p><h4 id="从-gt-主：REPLCONF-ACK"><a href="#从-gt-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h4><p>在命令传播阶段， <strong>从节点会向主节点发送REPLCONF ACK命令，</strong> 频率是每秒1次；</p><p><strong>命令格式为：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &#123;offset&#125;# offset指从节点保存的复制偏移量。</span><br></pre></td></tr></table></figure><p><strong>REPLCONF ACK命令的作用包括：</strong></p><ol><li><p><strong>实时监测主从节点网络状态：</strong> 该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</p></li><li><p><strong>检测命令丢失：</strong> 从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。</p></li></ol><ul><li><strong>注意：offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></li></ul><ol start="3"><li><strong>辅助保证从节点的数量和延迟：</strong> Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</li></ol><p>　　</p><h2 id="开启主从复制"><a href="#开启主从复制" class="headerlink" title="开启主从复制"></a>开启主从复制</h2><p>从节点开启主从复制，有3种方式：</p><ul><li>配置文件：在从服务器的配置文件中加入：<strong>slaveof <masterip> <masterport></strong></li><li>启动命令：redis-server启动命令后加入： <strong>–slaveof <masterip> <masterport></strong></li><li>客户端命令：Redis服务器启动后，直接通过客户端执行命令：<strong>slaveof <masterip> <masterport></strong>，则该Redis实例成为从节点。</li></ul><h3 id="修改配置文件方法："><a href="#修改配置文件方法：" class="headerlink" title="修改配置文件方法："></a>修改配置文件方法：</h3><h4 id="1-配置从服务配置文件redis-conf"><a href="#1-配置从服务配置文件redis-conf" class="headerlink" title="1. 配置从服务配置文件redis.conf"></a>1. 配置从服务配置文件redis.conf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.9 6379    #添加属于某台主机的从 服务</span><br><span class="line">masterauth 123456       #从服务连接主服的密码（访问主服务器的密码）</span><br><span class="line">slave-read-only yes     #从服务只读，不可在命令行写入数据</span><br><span class="line"></span><br><span class="line">5.0.4以后：</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replica-read-only yes</span><br></pre></td></tr></table></figure><h4 id="2-重新启动从服务即实现主从连接"><a href="#2-重新启动从服务即实现主从连接" class="headerlink" title="2. 重新启动从服务即实现主从连接"></a>2. 重新启动从服务即实现主从连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. ./bin/redis-cli# 启动redis客户端</span><br><span class="line">2. 输入 info replication # 查看与复制相关的状态，了解主从节点的当前状态</span><br></pre></td></tr></table></figure><p><strong>输入info replication 后显示的内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:slave      # 表示此台服务器是主是从</span><br><span class="line">master_host:39.107.38.62     # 主服务器ip</span><br><span class="line">master_port:6379        # 主服务器端口号</span><br><span class="line">master_link_status:up       # 与主服务器是否连接成功 up为成功 down失败</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:808</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:ea5230cc485f9c6f372b2c89a65613fb075aff8b</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:808</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:794</span><br></pre></td></tr></table></figure><h4 id="遇到的报错："><a href="#遇到的报错：" class="headerlink" title="遇到的报错："></a>遇到的报错：</h4><h5 id="1-Error-condition-on-socket-for-SYNC-Connection-refused"><a href="#1-Error-condition-on-socket-for-SYNC-Connection-refused" class="headerlink" title="1. Error condition on socket for SYNC: Connection refused"></a>1. Error condition on socket for SYNC: Connection refused</h5><p>  <strong>出现原因</strong>：redis主服务器绑定了127.0.0.1，跨服务器IP的访问就会失败，只能本机才能访问，外部请求会被过滤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line"><span class="number">1.</span> 主服务器绑定ip: bind <span class="number">39.107</span><span class="number">.38</span><span class="number">.62</span></span><br><span class="line"><span class="number">3.</span> bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="number">2.</span> 注释bind  <span class="comment"># 会报下面的错↓</span></span><br></pre></td></tr></table></figure><h5 id="2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec"><a href="#2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec" class="headerlink" title="2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec"></a>2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec</h5><p>   <strong>出现原因</strong>：处于保护模式，只能本地链接。没有绑定ip 没有设置验证密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip： bind 39.107.38.62</span><br><span class="line">2. 设置主服务器访问密码：requirepass 12345</span><br></pre></td></tr></table></figure><h5 id="3-error-READONLY-You-can’t-write-against-a-read-only-replica"><a href="#3-error-READONLY-You-can’t-write-against-a-read-only-replica" class="headerlink" title="3. (error) READONLY You can’t write against a read only replica."></a>3. (error) READONLY You can’t write against a read only replica.</h5><p>​    <strong>出现原因</strong>：从库只可读不可写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 设置slave-read-only no # 代表不限于只读</span><br></pre></td></tr></table></figure><h2 id="断开主从复制"><a href="#断开主从复制" class="headerlink" title="断开主从复制"></a>断开主从复制</h2><p>​    通过 <strong>slaveof <masterip> <masterport></strong> 命令建立主从复制关系以后，可以通过slaveof no one断开。</p><p>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的安装</title>
      <link href="/2019/05/02/Redis%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/05/02/Redis%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装gcc"><a href="#1-安装gcc" class="headerlink" title="1. 安装gcc"></a>1. 安装gcc</h2><blockquote><p>redis是c语言编写的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><h2 id="2-下载redis安装包-在root目录下执行"><a href="#2-下载redis安装包-在root目录下执行" class="headerlink" title="2. 下载redis安装包,在root目录下执行"></a>2. 下载redis安装包,在root目录下执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.4.tar.gz</span><br></pre></td></tr></table></figure><h2 id="3-解压redis安装包"><a href="#3-解压redis安装包" class="headerlink" title="3. 解压redis安装包"></a>3. 解压redis安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-5.0.4.tar.gz     #解压gz属性的压缩包</span><br></pre></td></tr></table></figure><h2 id="4-进入redis目录"><a href="#4-进入redis目录" class="headerlink" title="4. 进入redis目录"></a>4. 进入redis目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-5.0.4</span><br></pre></td></tr></table></figure><h2 id="5-编译"><a href="#5-编译" class="headerlink" title="5. 编译"></a>5. 编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="6-安装"><a href="#6-安装" class="headerlink" title="6. 安装"></a>6. 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure><h2 id="7-拷贝redis-conf到安装目录"><a href="#7-拷贝redis-conf到安装目录" class="headerlink" title="7. 拷贝redis.conf到安装目录"></a>7. 拷贝redis.conf到安装目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf /usr/local/redis</span><br></pre></td></tr></table></figure><h2 id="8-进入-usr-local-redis目录"><a href="#8-进入-usr-local-redis目录" class="headerlink" title="8. 进入 /usr/local/redis目录"></a>8. 进入 /usr/local/redis目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/redis/</span><br></pre></td></tr></table></figure><h2 id="9-编辑redis-conf"><a href="#9-编辑redis-conf" class="headerlink" title="9. 编辑redis.conf"></a>9. 编辑redis.conf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line"></span><br><span class="line">1.后台启动，daemonize yes</span><br><span class="line"></span><br><span class="line">2.绑定端口，port 6379 默认是6379 需要安全组开放端口</span><br><span class="line"></span><br><span class="line">3.绑定IP，bind 192.168.2.128</span><br><span class="line"></span><br><span class="line">4.指定数据存放路径，dir /usr/local/redis/log rdb存放的路径</span><br><span class="line"></span><br><span class="line">5.指定持久化方式，appendonly yes</span><br><span class="line"></span><br><span class="line">6.requirepass redis129 设置密码</span><br><span class="line"></span><br><span class="line">7.指定日志存储地址, logfile &quot;/usr/local/redis/log/redis_run.log&quot;</span><br><span class="line"></span><br><span class="line"># 不指定日志将会被发送到/dev/null</span><br></pre></td></tr></table></figure><h2 id="10-前端启动-无法部署集群"><a href="#10-前端启动-无法部署集群" class="headerlink" title="10. 前端启动-无法部署集群"></a>10. 前端启动-无法部署集群</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server</span><br></pre></td></tr></table></figure><h2 id="11-后端启动redis："><a href="#11-后端启动redis：" class="headerlink" title="11. 后端启动redis："></a>11. 后端启动redis：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./redis.conf</span><br></pre></td></tr></table></figure><h2 id="12-查看是否启动成功："><a href="#12-查看是否启动成功：" class="headerlink" title="12. 查看是否启动成功："></a>12. 查看是否启动成功：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep redis</span><br></pre></td></tr></table></figure><h2 id="13-进入客户端"><a href="#13-进入客户端" class="headerlink" title="13. 进入客户端"></a>13. 进入客户端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-cli --raw 处理中文乱码问题</span><br></pre></td></tr></table></figure><h2 id="14-关闭redis进程"><a href="#14-关闭redis进程" class="headerlink" title="14. 关闭redis进程"></a>14. 关闭redis进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 进入客户端 ./bin/redis-cli</span><br><span class="line">2. 输入 shutdown</span><br></pre></td></tr></table></figure><h2 id="15-卸载redis"><a href="#15-卸载redis" class="headerlink" title="15. 卸载redis"></a>15. 卸载redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove redis</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传文件到gitee</title>
      <link href="/2019/02/06/git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0gitee/"/>
      <url>/2019/02/06/git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0gitee/</url>
      
        <content type="html"><![CDATA[<p><strong>在本地项目文件中使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的名字&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>1. 初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br><span class="line"></span><br><span class="line">git remote add origin https://gitee.com/xxx/xxx.git (你的远程项目地址)</span><br></pre></td></tr></table></figure><p><strong>2. 克隆一下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://****.git (你的远程项目地址)</span><br></pre></td></tr></table></figure><p><strong>3. 提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;提交备注&quot;</span><br><span class="line"></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><strong>push Vue项目时 要用强制推送：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字典底层</title>
      <link href="/2019/01/19/Python%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82/"/>
      <url>/2019/01/19/Python%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="字典数据类型的hashmap"><a href="#字典数据类型的hashmap" class="headerlink" title="字典数据类型的hashmap"></a>字典数据类型的hashmap</h2><p>python里的字典采用了哈希表，就像java里的HashMap，以键值对的方式存在并操作，最低能在 O(1)时间内完成搜索。</p><p><strong>什么是哈希表：</strong></p><p>​    简单来说就是一张带索引和存储空间的表，对于任意可哈希对象，通过哈希索引的计算公式：<strong>hash(hashable)%k</strong>（对可哈希对象进行哈希计算，然后对结果进行取余运算），可将该对象映射为0到k-1之间的某个表索引，然后在该索引所对应的空间进行变量的存储/读取等操作。 </p><table><thead><tr><th>哈希运算结果</th><th>取余运算结果</th><th>索引</th><th>键值对</th></tr></thead><tbody><tr><td>hash(‘小王’)=2360347816510736229</td><td>2360347816510736229%3=0</td><td>0</td><td>‘小王‘：26</td></tr><tr><td>hash(‘大熊’)=4284897975392025871</td><td>4284897975392025871%3=1</td><td>1</td><td>‘大熊’：28</td></tr><tr><td>hash(‘牛牛’)=-7069010861127204901</td><td>-7069010861127204901%3=2</td><td>2</td><td>‘牛牛’：3</td></tr></tbody></table><p><strong>其特点如下：</strong></p><ol><li><p>通过键来存取，而非偏移量;</p></li><li><p>键值对是无序的;</p></li><li><p>键和值可以是任意对象;</p></li><li><p>长度可变，任意嵌套;</p></li><li><p>在字典里，不能再有序列操作，虽然字典在某些方面与列表类似，但不要把列表套在字典上;</p></li></ol><p><strong>Python字典如何运用哈希表：</strong></p><p>我们通过描述插入，查询，删除，扩容，哈希碰撞这几个过程来解释这一切。</p><p><strong>插入：</strong>对键进行哈希和取余运算，得到一个哈希表的索引，如果该索引所对应的表地址空间为空，将键值对存入该地址空间；</p><p><strong>更新：</strong>对键进行哈希和取余运算，得到一个哈希表的索引，如果该索引所对应的地址空间中健与要更新的健一致，那么就更新该健所对应的值；</p><p><strong>查询：</strong>对要查找的健进行哈希和取余运算，得到一个哈希表的索引，如果该索引所对应的地址空间中健与要查询的健一致，那么就将该键值对取出来；</p><p><strong>扩容：</strong>字典初始化的时候，会对应初始化一个有k个空间的表，等空间不够用的时候，系统就会自动扩容，这时候会对已经存在的键值对重新进行哈希取余运算（重新进行插入操作）保存到其它位置；</p><p><strong>碰撞：</strong>有时候对于不同的键，经过哈希取余运算之后，得到的索引值一样，这时采用公开寻址的方式，运用固定的模式将键值对插入到其它的地址空间，比如线性寻址：如果第i个位置已经被使用，我们就看看第i+1个，第i+2个，第i+3个有没有被使用…直到找到一个空间或者对空间进行扩容。</p><p>比如：我们想存储 {’小小‘：18}这个键值对，经过哈希和取余运算之后，我们发现，其对应的索引值是0，但是0所指向的空间已经被’小王‘占用了，这就是碰撞。怎么办呢？我们看看0+1对应的所以有没有被占用，如果没有，我们就把’小小‘放在索引1所对应的地址空间中。取的时候，也按照同样的规则，进行探查。</p><table><thead><tr><th>哈希运算</th><th>取余运算</th><th>索引值</th><th>键值对</th></tr></thead><tbody><tr><td>hash(‘小王’)=2360347816510736229</td><td>2360347816510736229%3=0</td><td>0</td><td>’小王‘：26</td></tr><tr><td>hash(‘小小’)=-2310146166101152587</td><td>-2310146166101152587%3=0</td><td>1</td><td>’小小‘：18</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>Cython 中 哈希表的计算公式为：hash(‘hashable’)&amp;k，其中k 为2的n次方减1，其实与hash(‘hashable’)%(k+1)的结果一致。</p></li><li><p>解决碰撞的方法，Python用的不是线性寻址，而是一种更为复杂的寻址模式。<a href="https://blog.csdn.net/qq_42815145/article/details/91353624#fn2" target="_blank" rel="noopener">2</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql主从</title>
      <link href="/2018/12/08/Mysql%E4%B8%BB%E4%BB%8E/"/>
      <url>/2018/12/08/Mysql%E4%B8%BB%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql主从"><a href="#Mysql主从" class="headerlink" title="Mysql主从"></a>Mysql主从</h2><ul><li>什么是<strong>主从复制</strong>？</li></ul><blockquote><p>主从复制至少需要两台服务器，或两个<strong>mysql</strong>服务，可以配置一主多从，多主多从</p><p>建立与某个业务数据库一样的数据库环境，即为主从复制</p><p>一般情况下，主库用以写，而从库用以读</p></blockquote><ul><li><strong>Mysql主从原理：</strong><ul><li>利用数据库<strong>bin-log</strong>二进制文件，该文件包含有数据库操作的所有SQL语句</li></ul></li></ul><p>复制该文件至其余数据库服务中并执行即可。</p><ol><li>从库建立IO线程连接主库主库响应连接开始线程，传输binlog</li><li>从库IO线程接收binlog写入relaylog</li><li>从库SQL线程，处理relaylog，写入db</li></ol><ul><li><p><strong>主从复制过程：</strong></p><ol><li><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输<strong>binlog</strong>日志</p></li><li><p>从库开启两个线程：</p><ul><li>A线程：也叫做<strong>IO线程</strong>，连接主库，并请求binlog中的更新记录至从库中，写入至从库的<strong>relaylog</strong>文件中</li><li>B线程：也叫做<strong>SQL线程</strong>，读取<strong>relaylog</strong>文件中的更新操作并执行</li></ul></li><li><p>如果，有多个从库同时存在，主库会为每个从库建立一个<strong>binlog</strong>输出线程</p></li></ol></li></ul><ul><li><p><strong>Mysql主从作用</strong></p><ol><li>构建主从热备，当某天数据库宕机或或数据丢失情况，可以有备份数据库继续工作</li><li>降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</li><li>隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</li></ol></li></ul><ul><li><p><strong>主机binlog日志：</strong></p><ul><li><p>binlog日志存的二进制 增删改操作。</p></li><li><p>binlog存储地址：/var/lib/mysql/    名为：mysql-bin.000001</p></li><li><p><strong>binlog不能直接cat命令查看，需要用到mysql的日志管理工具：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 查看mysql的主机binlog文件mysqlbinlog /var/lib/mysql/mysql-bin.000001</span><br><span class="line">2. mysqlbinlog /var/lib/mysql/mysql-bin.000001 | tail -n 10 </span><br><span class="line"><span class="meta">#</span><span class="bash"> tail -n 10 表示查看末尾十行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> head -n 10 表示查看开头十行</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>从机relay_log日志</strong></p><ul><li>relay_log中存储的需要同步的新的信息</li></ul></li></ul><h2 id="Mysql主从配置"><a href="#Mysql主从配置" class="headerlink" title="Mysql主从配置"></a>Mysql主从配置</h2><ol><li><p>主机开启binlog日志</p></li><li><p>配置文件：</p><p><strong>主机：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">symbolic-links=0</span><br><span class="line">binlog_format=mixed</span><br><span class="line">server-id = 1 # 用来表示数据库身份 类似pid</span><br><span class="line">log-bin=mysql-bin# 开启binlog日志</span><br><span class="line">expire_logs_days=7</span><br><span class="line">general_log=1</span><br><span class="line">general_log_file=/var/lib/mysql/general.log</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/var/log/mariadb/mariadb.log</span><br><span class="line">pid-file=/var/run/mariadb/mariadb.pid</span><br><span class="line"></span><br><span class="line"># include all files from the config directory</span><br><span class="line">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure><p><strong>从机：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line">binlog_format=mixed</span><br><span class="line">server-id = 2# 不能和主库一样</span><br><span class="line"># 从机不用开启log-bin功能</span><br><span class="line">expire_logs_days=7</span><br><span class="line">general_log=1</span><br><span class="line">general_log_file=/var/lib/mysql/general.log</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/var/log/mariadb/mariadb.log</span><br><span class="line">pid-file=/var/run/mariadb/mariadb.pid</span><br></pre></td></tr></table></figure></li><li><p>重启服务:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure></li><li><p>主库创建用户，用以从机连接获取<strong>binlog</strong>日志</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看mysql内的所有用户：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 首先进入mysql</span><br><span class="line">grant replication slave on *.* to &apos;master&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br><span class="line"># 创建了一个为从库工作的master用户，密码是123456，所对应的库*.*（所有的库）</span><br><span class="line">flush privileges;# 刷新权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to master@&apos;%&apos; identified by &quot;123456&quot;;</span><br><span class="line"># 为了保险起见，又给用户赋予了所有数据库的权限</span><br></pre></td></tr></table></figure></code></pre><ol start="5"><li><p>查看master状态</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line">| mysql-bin.000002 |     3755 |              |                  |</span><br><span class="line">+------------------+----------+--------------+------------------+</span><br><span class="line"># File: binlog日志名称</span><br><span class="line"># Position: 从库从哪个位置开始同步</span><br></pre></td></tr></table></figure></li><li><p>从库指定master</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;47.97.218.145&apos;, master_port=3306, master_user=&apos;master&apos;, master_password=&apos;123456&apos;, master_log_file=&apos;mysql-bin.000002&apos;, master_log_pos=3755;</span><br><span class="line"></span><br><span class="line"># master_hos： 主机ip地址</span><br><span class="line"># master_port：主机端口号</span><br><span class="line"># master_user：主机创建的用来连接从库的用户</span><br><span class="line"># master_password：主机数据库密码</span><br><span class="line"># master_log_file: 使用show master status;命令查出的binlog日志名称</span><br><span class="line"># master_log_pos:  使用show master status;命令查出的同步位置</span><br></pre></td></tr></table></figure><ul><li><p>当你上一条命令配置出错时，可以重置slave状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset slave all;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>连接主从：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看从机状态：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 47.97.218.145# 主机ip</span><br><span class="line">                  Master_User: master# 连接主从用户名</span><br><span class="line">                  Master_Port: 3306# 主机端口号</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000003# 同步的主机binlog</span><br><span class="line">          Read_Master_Log_Pos: 245# 同步起点</span><br><span class="line">               Relay_Log_File: mariadb-relay-bin.000005# 从机relaylog名称</span><br><span class="line">                Relay_Log_Pos: 529</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000003</span><br><span class="line">             Slave_IO_Running: Yes# yes为链接成功</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 245</span><br><span class="line">              Relay_Log_Space: 868</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 1</span><br></pre></td></tr></table></figure></li><li><p>停止从库状态：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure></li></ol><p>主从需要注意的事项：</p><ol><li><p>mysqldump</p></li><li><p>如果从机断了，主库在疯狂增删改，从机过了一阵又启动了，重启回复从库状态</p></li><li><p>如果主机断了，写入直接进制了，此时用户想写，怎么能暂时吧从机变为可写的主机</p><p>一主多从</p></li><li><p>主从延迟，主从数据库尽量在同一局域网下，网速更快，服务器性能更好，磁盘要好</p><p>从库没必要开binlog就不开了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python算法</title>
      <link href="/2018/11/20/python%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/20/python%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归实现单链表反转</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">    self.val=x</span><br><span class="line">    self.next=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recurse</span><span class="params">(head,newhead)</span>:</span>  <span class="comment">#递归，head为原链表的头结点，newhead为反转后链表的头结点</span></span><br><span class="line">  <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> head.next <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    newhead=head</span><br><span class="line">  <span class="keyword">else</span> :</span><br><span class="line">    newhead=recurse(head.next,newhead)</span><br><span class="line">    head.next.next=head</span><br><span class="line">    head.next=<span class="literal">None</span></span><br><span class="line">  <span class="keyword">return</span> newhead</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    head=ListNode(<span class="number">1</span>)       <span class="comment">#测试代码</span></span><br><span class="line">    p1=ListNode(<span class="number">2</span>)       <span class="comment"># 建立链表1-&gt;2-&gt;3-&gt;4-&gt;None</span></span><br><span class="line">    p2=ListNode(<span class="number">3</span>)</span><br><span class="line">    p3=ListNode(<span class="number">4</span>)</span><br><span class="line">    head.next=p1</span><br><span class="line">    p1.next=p2</span><br><span class="line">    p2.next=p3</span><br><span class="line">    newhead=<span class="literal">None</span></span><br><span class="line">    p=recurse(head,newhead)    <span class="comment">#输出链表4-&gt;3-&gt;2-&gt;1-&gt;None</span></span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">      print(p.val)</span><br><span class="line">      p=p.next</span><br></pre></td></tr></table></figure><h2 id="艾氏筛法求质数"><a href="#艾氏筛法求质数" class="headerlink" title="艾氏筛法求质数"></a>艾氏筛法求质数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></span><br><span class="line">    n =<span class="number">1</span></span><br><span class="line">    <span class="comment"># while True:</span></span><br><span class="line">    <span class="comment">#   n = n+2</span></span><br><span class="line">    <span class="comment">#   yield n</span></span><br><span class="line">    <span class="keyword">return</span> itertools.count(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_divisable</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x %n&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = next(it)</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(not_divisable(n),it)</span><br><span class="line">p = primes()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(next(p))</span><br></pre></td></tr></table></figure><h2 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(blist)</span>:</span></span><br><span class="line">    count = len(blist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> blist[i] &gt; blist[j]:                 </span><br><span class="line">                blist[i], blist[j] = blist[j], blist[i]</span><br><span class="line">    <span class="keyword">return</span> blist  </span><br><span class="line">blist = bubble_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>]) </span><br><span class="line">print(blist)</span><br></pre></td></tr></table></figure><h2 id="快排："><a href="#快排：" class="headerlink" title="快排："></a>快排：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]    <span class="comment">#找到一个基准值</span></span><br><span class="line">        <span class="comment">#遍历整个列表，将小于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">        <span class="comment">#遍历整个列表，将大于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;pivot]</span><br><span class="line">        <span class="comment">#首先，明确我们对元素为0个/1个的列表无需要排序</span></span><br><span class="line">        <span class="comment">#使用函数递归</span></span><br><span class="line">        <span class="comment">#目标：让我们在一个基准值的一侧变为有序，然后依次返回，让我们的每个基准值的两侧都变得有序</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less)+[pivot]+quicksort(greater)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这是一些测试样例</span></span><br><span class="line">print(quicksort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">11</span>]))</span><br><span class="line">print(quicksort([<span class="number">152</span>,<span class="number">134</span>,<span class="number">38796</span>,<span class="number">7438415</span>,<span class="number">1</span>,<span class="number">2272</span>,<span class="number">34345</span>,<span class="number">24</span>,<span class="number">127</span>]))</span><br></pre></td></tr></table></figure><h2 id="杨氏矩阵查找"><a href="#杨氏矩阵查找" class="headerlink" title="杨氏矩阵查找"></a>杨氏矩阵查找</h2><p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>使用Step-wise线性搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(l, r, c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> l[r][c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(l, x)</span>:</span></span><br><span class="line">    m = len(l) - <span class="number">1</span></span><br><span class="line">    n = len(l[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    c = n</span><br><span class="line">    <span class="keyword">while</span> c &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt;= m:</span><br><span class="line">        value = get_value(l, r, c)</span><br><span class="line">        <span class="keyword">if</span> value == x:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> value &gt; x:</span><br><span class="line">            c = c - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> value &lt; x:</span><br><span class="line">            r = r + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p><blockquote><p>第<code>2*n</code>个矩形的覆盖方法等于第<code>2*(n-1)</code>加上第<code>2*(n-2)</code>的方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> n: <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="单例"><a href="#单例" class="headerlink" title="单例:"></a>单例:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">single1 = Single()</span><br><span class="line">single2 = Single()</span><br><span class="line">print(id(single1) , id(single2))</span><br></pre></td></tr></table></figure><h2 id="递归斐波那契："><a href="#递归斐波那契：" class="headerlink" title="递归斐波那契："></a>递归斐波那契：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fun(i<span class="number">-2</span>) + fun(i<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(fun(i),end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure><h2 id="递归遍历目录："><a href="#递归遍历目录：" class="headerlink" title="递归遍历目录："></a>递归遍历目录：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dir</span><span class="params">(path,level=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        file_path = os.path.join(path,file)</span><br><span class="line">        print(<span class="string">'-'</span> * level,file)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(file_path):</span><br><span class="line">            get_dir(file_path, level + <span class="number">1</span>)</span><br><span class="line">get_dir(<span class="string">r'path'</span>)</span><br></pre></td></tr></table></figure><h2 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">闭包的定义：</span></span><br><span class="line"><span class="string">在一个外函数中定义了一个内函数</span></span><br><span class="line"><span class="string">内函数里运用了外函数的临时变量</span></span><br><span class="line"><span class="string">并且外函数的返回值是内函数的引用。</span></span><br><span class="line"><span class="string">这样就构成了一个闭包。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">innter</span><span class="params">()</span>:</span></span><br><span class="line">        b = a + <span class="number">10</span></span><br><span class="line">        print(<span class="string">"b ="</span>,b)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">outer()()</span><br></pre></td></tr></table></figure><h2 id="装饰器测试程序运行时间："><a href="#装饰器测试程序运行时间：" class="headerlink" title="装饰器测试程序运行时间："></a>装饰器测试程序运行时间：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用装饰器测试（1000以内的三个数，相加等于1000的情况，有多少组）这个案例的运行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        s_time = time.time() <span class="comment">#获取程序运行的开始时间</span></span><br><span class="line">        fun()    <span class="comment">#运行程序</span></span><br><span class="line">        e_time = time.time() <span class="comment">#获取程序运行的结束时间</span></span><br><span class="line">        <span class="keyword">return</span> e_time-s_time</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="meta">@time_</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">            c = <span class="number">1000</span> - a - b</span><br><span class="line">            <span class="keyword">if</span> a ** <span class="number">2</span> + b ** <span class="number">2</span> == c ** <span class="number">2</span>:</span><br><span class="line">                print(<span class="string">"a = %d , b = %d , c = %d"</span> % (a,b,c)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(func())</span><br></pre></td></tr></table></figure><h2 id="python实现树，实现前中后遍历和层次遍历"><a href="#python实现树，实现前中后遍历和层次遍历" class="headerlink" title="python实现树，实现前中后遍历和层次遍历"></a>python实现树，实现前中后遍历和层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''树的节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span>  <span class="comment">#左孩子</span></span><br><span class="line">        self.rchild = <span class="literal">None</span>  <span class="comment">#右孩子</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''二叉树'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span>    <span class="comment"># 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''添加的方法'''</span></span><br><span class="line">        node = Node(item)   <span class="comment"># 先构造一个节点</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment">#     如果是空树 直接添加元素</span></span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]  <span class="comment"># 一个队列 用来存放的就是要遍历和处理的元素</span></span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment">#队列只要不为空 就始终能拿出节点进行判断</span></span><br><span class="line">            <span class="comment"># 先从队列中取出一个节点</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 看当前这个节点左边的孩子是否为空 如果是空 直接挂节点</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不为空则认定左孩子存在 追加到队列</span></span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 查看节点右孩子 与左孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breadth_trvael</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''层次遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment"># 只要队列不为空就一直取元素</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur_node.elem,end=<span class="string">' '</span>)</span><br><span class="line">            <span class="comment"># 如果左孩子存在 添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 右孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, node)</span>:</span>   <span class="comment">#传一个根节点</span></span><br><span class="line">        <span class="string">'''先序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:    <span class="comment">#递归的终结条件</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(node.elem,end=<span class="string">' '</span>)    <span class="comment">#先打印根</span></span><br><span class="line">        self.preorder(node.lchild)  <span class="comment">#处理左半部分</span></span><br><span class="line">        self.preorder(node.rchild)  <span class="comment">#处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''中序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment">#输出根</span></span><br><span class="line">        self.inorder(node.rchild)  <span class="comment">#再处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''后序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        self.postorder(node.rchild)  <span class="comment"># 然后处理右半部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment"># 最后输出根</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tree = Tree()</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    tree.add(<span class="number">0</span>)</span><br><span class="line">    tree.add(<span class="number">1</span>)</span><br><span class="line">    tree.add(<span class="number">2</span>)</span><br><span class="line">    tree.add(<span class="number">3</span>)</span><br><span class="line">    tree.add(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">'层次遍历：'</span>)</span><br><span class="line">    tree.breadth_trvael()</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'先序遍历：'</span>)</span><br><span class="line">    tree.preorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'中序遍历：'</span>)</span><br><span class="line">    tree.inorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'后序遍历：'</span>)</span><br><span class="line">    tree.postorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h2 id="实现单向链表"><a href="#实现单向链表" class="headerlink" title="实现单向链表"></a>实现单向链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''单链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node=None)</span>:</span></span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="literal">None</span>    <span class="comment">#如果头节点为空 列表就为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表长度'''</span></span><br><span class="line">        cur = self.head <span class="comment">#cur游标 用来移动遍历节点</span></span><br><span class="line">        count = <span class="number">0</span>        <span class="comment">#记录数量</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next    <span class="comment">#移动游标</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''遍历整个链表'''</span></span><br><span class="line">        cur = self.head <span class="comment">#代表第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''在链表头部添加元素，头插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self.head   <span class="comment"># 新元素的下一个节点指向链表第一个元素</span></span><br><span class="line">        self.head = node    <span class="comment">#头节点指向新元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''向链表的尾部添加元素,尾插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty(): <span class="comment">#如果链表为空</span></span><br><span class="line">            self.head = node    <span class="comment">#头节点指向添加的元素</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#不为空</span></span><br><span class="line">            cur = self.head     <span class="comment"># 游标</span></span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>: <span class="comment"># 游标下一个位置不为空开始进入循环 为空则不进入循环</span></span><br><span class="line">                cur = cur.next  <span class="comment"># 游标移动</span></span><br><span class="line">            cur.next = node <span class="comment">#当游标下一位置为空时添加元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span>    <span class="comment"># 传入一个插入位置pos 一个插入元素item</span></span><br><span class="line">        <span class="string">'''指定位置添加元素'''</span></span><br><span class="line">        <span class="comment"># 如果添加位置在头部 直接使用头插入方法</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span> :</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):   <span class="comment">#插入位置超出列表范围 使用尾插法</span></span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 当循环退出后cur指向 pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''删除元素,根据具体的数据删除'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span>    <span class="comment"># 前一位置</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断子节点是否为头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = cur.next <span class="comment"># 直接改变头指针指向的地址</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cur.next <span class="comment"># 如果删除尾部 cur.next刚好指向none</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点是否存在'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:  <span class="comment"># 列表不为空时</span></span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    ll.append(<span class="number">2</span>)    <span class="comment">#尾部添加</span></span><br><span class="line">    ll.append(<span class="number">6</span>)</span><br><span class="line">    ll.add(<span class="number">8</span>)   <span class="comment">#头部添加</span></span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.insert(<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'开始遍历链表元素：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="comment"># 删除一个元素</span></span><br><span class="line">    ll.remove(<span class="number">6</span>)</span><br><span class="line">    print(<span class="string">'删除后遍历：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">10</span>))</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">9</span>))</span><br></pre></td></tr></table></figure><h2 id="链表成对调换"><a href="#链表成对调换" class="headerlink" title="链表成对调换"></a>链表成对调换</h2><p><code>1-&gt;2-&gt;3-&gt;4</code>转换成<code>2-&gt;1-&gt;4-&gt;3</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head != <span class="literal">None</span> <span class="keyword">and</span> head.next != <span class="literal">None</span>:</span><br><span class="line">            next = head.next</span><br><span class="line">            head.next = self.swapPairs(next.next)</span><br><span class="line">            next.next = head</span><br><span class="line">            <span class="keyword">return</span> next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="交叉链表求交点"><a href="#交叉链表求交点" class="headerlink" title="交叉链表求交点"></a>交叉链表求交点</h2><blockquote><p>其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    length1, length2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.next:</span><br><span class="line">        l1 = l1.next<span class="comment">#尾节点</span></span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.next:</span><br><span class="line">        l2 = l2.next<span class="comment">#尾节点</span></span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#如果相交</span></span><br><span class="line">    <span class="keyword">if</span> l1.next == l2.next:</span><br><span class="line">        <span class="comment"># 长的链表先走</span></span><br><span class="line">        <span class="keyword">if</span> length1 &gt; length2:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length1 - length2):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">return</span> l1<span class="comment">#返回交点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(length2 - length1):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">return</span> l2<span class="comment">#返回交点</span></span><br><span class="line">    <span class="comment"># 如果不相交</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Stack() 创建一个新的空栈</span></span><br><span class="line"><span class="string">push(item) 添加一个新的元素item到栈顶</span></span><br><span class="line"><span class="string">pop() 弹出栈顶元素</span></span><br><span class="line"><span class="string">peek() 返回栈顶元素</span></span><br><span class="line"><span class="string">is_empty() 判断栈是否为空</span></span><br><span class="line"><span class="string">size() 返回栈的元素个数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""栈类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空栈"""</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""添加一个新的元素到栈顶"""</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""弹出栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断栈是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈元素的个数"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    print(s.is_empty())<span class="comment">#判断栈是否为空</span></span><br><span class="line">    print(s.size())<span class="comment"># 获取栈的大小</span></span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)<span class="comment">#添加元素</span></span><br><span class="line">    s.push(<span class="number">6</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    print(s.stack)<span class="comment">#输出栈</span></span><br><span class="line">    print(s.pop())<span class="comment">#弹出栈顶元素</span></span><br><span class="line">    print(s.size())<span class="comment">#获取栈的大小</span></span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(s.is_empty())</span><br><span class="line">    print(s.size())</span><br></pre></td></tr></table></figure><h2 id="实现队列："><a href="#实现队列：" class="headerlink" title="实现队列："></a>实现队列：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Queue() 创建一个空的队列</span></span><br><span class="line"><span class="string">enqueue(item) 往队列中添加一个item元素</span></span><br><span class="line"><span class="string">dequeue() 从队列头部删除一个元素</span></span><br><span class="line"><span class="string">is_empty() 判断一个队列是否为空</span></span><br><span class="line"><span class="string">size() 返回队列的大小</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空队列"""</span></span><br><span class="line">        self.queue = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""往队列中添加一个元素"""</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队列头部删除一个元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ie_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断一个队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line">    q.enqueue(<span class="number">6</span>)</span><br><span class="line">    q.enqueue(<span class="number">7</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br></pre></td></tr></table></figure><h2 id="不用循环和条件打印1-1000"><a href="#不用循环和条件打印1-1000" class="headerlink" title="不用循环和条件打印1~1000"></a>不用循环和条件打印1~1000</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">1005</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnum</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">return</span> (n<span class="number">-1000</span>) <span class="keyword">and</span> printnum(n+<span class="number">1</span>)</span><br><span class="line">printnum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#values是硬币的面值values = [ 25, 21, 10, 5, 1]</span></span><br><span class="line"><span class="comment">#valuesCounts   钱币对应的种类数</span></span><br><span class="line"><span class="comment">#money  找出来的总钱数</span></span><br><span class="line"><span class="comment">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(values,valuesCounts,money,coinsUsed)</span>:</span></span><br><span class="line">    <span class="comment">#遍历出从1到money所有的钱数可能</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>,money+<span class="number">1</span>):</span><br><span class="line">        minCoins = cents</span><br><span class="line">        <span class="comment">#把所有的硬币面值遍历出来和钱数做对比</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> range(<span class="number">0</span>,valuesCounts):</span><br><span class="line">            <span class="keyword">if</span> (values[kind] &lt;= cents):</span><br><span class="line">                temp = coinsUsed[cents - values[kind]] +<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; minCoins):</span><br><span class="line">                    minCoins = temp</span><br><span class="line">        coinsUsed[cents] = minCoins</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;'</span>.format(cents, coinsUsed[cents]))</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list, item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (high - low) / <span class="number">2</span> + low    <span class="comment"># 避免(high + low) / 2溢出</span></span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> guess &lt; item:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(mylist, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="去除列表中的重复元素"><a href="#去除列表中的重复元素" class="headerlink" title="去除列表中的重复元素"></a>去除列表中的重复元素</h2><h4 id="用集合"><a href="#用集合" class="headerlink" title="用集合"></a>用集合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">print(list(set(my_list)))</span><br></pre></td></tr></table></figure><h4 id="用字典"><a href="#用字典" class="headerlink" title="用字典"></a>用字典</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure><h4 id="用字典并保持顺序"><a href="#用字典并保持顺序" class="headerlink" title="用字典并保持顺序"></a>用字典并保持顺序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = list(set(l1))</span><br><span class="line">l2.sort(key=l1.index)</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = []</span><br><span class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> l2]</span><br></pre></td></tr></table></figure><h4 id="sorted排序并且用列表推导式"><a href="#sorted排序并且用列表推导式" class="headerlink" title="sorted排序并且用列表推导式."></a>sorted排序并且用列表推导式.</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>][single.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> sorted(l) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> single] <span class="keyword">print</span> single</span><br></pre></td></tr></table></figure><h2 id="青蛙跳台阶递归"><a href="#青蛙跳台阶递归" class="headerlink" title="青蛙跳台阶递归"></a>青蛙跳台阶递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leap_frog</span><span class="params">(step)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> step &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"输入错误"</span></span><br><span class="line">    <span class="keyword">if</span> step == <span class="number">1</span> <span class="keyword">or</span> step == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> leap_frog(step<span class="number">-1</span>) + leap_frog(step<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(leap_frog(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="变态台阶问题"><a href="#变态台阶问题" class="headerlink" title="变态台阶问题"></a>变态台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = lambda n: n if n &lt; 2 else 2 * fib(n - 1)</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度：O(n²)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment"># 稳定性：稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ilist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ilist)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> ilist[i] &lt; ilist[j]:</span><br><span class="line">                ilist.insert(j, ilist.pop(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ilist</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；</p><p>第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；</p><p>以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度：O(n²)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment"># 稳定性：不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(slist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slist)):</span><br><span class="line">        x = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(slist)):</span><br><span class="line">            <span class="keyword">if</span> slist[j] &lt; slist[x]:</span><br><span class="line">                x = j</span><br><span class="line">        slist[i], slist[x] = slist[x], slist[i]</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line">slist = select_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>将已有序的子序列合并，得到完全有序的序列；</p><p>即先使每个子序列有序，再使子序列段间有序。</p><p>若将两个有序表合并成一个有序表，称为二路归并.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间复杂度：O(nlog₂n)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment"># 稳定性：稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_arr</span><span class="params">(arr_l, arr_r)</span>:</span></span><br><span class="line">        array = []</span><br><span class="line">        <span class="keyword">while</span> len(arr_l) <span class="keyword">and</span> len(arr_r):</span><br><span class="line">            <span class="keyword">if</span> arr_l[<span class="number">0</span>] &lt;= arr_r[<span class="number">0</span>]:</span><br><span class="line">                array.append(arr_l.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">elif</span> arr_l[<span class="number">0</span>] &gt; arr_r[<span class="number">0</span>]:</span><br><span class="line">                array.append(arr_r.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> len(arr_l) != <span class="number">0</span>:</span><br><span class="line">            array += arr_l</span><br><span class="line">        <span class="keyword">elif</span> len(arr_r) != <span class="number">0</span>:</span><br><span class="line">            array += arr_r</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(array) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        mid = len(array) // <span class="number">2</span></span><br><span class="line">        arr_l = recursive(array[:mid])</span><br><span class="line">        arr_r = recursive(array[mid:])</span><br><span class="line">        <span class="keyword">return</span> merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(array)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/2018/11/13/Python/"/>
      <url>/2018/11/13/Python/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h2><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><blockquote><p>时间复杂度：O(n²)<br>空间复杂度：O(1)<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(blist)</span>:</span></span><br><span class="line">    count = len(blist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> blist[i] &gt; blist[j]:</span><br><span class="line">                blist[i], blist[j] = blist[j], blist[i]</span><br><span class="line">    <span class="keyword">return</span> blist</span><br><span class="line"></span><br><span class="line">blist = bubble_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">print(blist)</span><br></pre></td></tr></table></figure><h2 id="快排："><a href="#快排：" class="headerlink" title="快排："></a>快排：</h2><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><blockquote><p>时间复杂度：O(nlog₂n)<br>空间复杂度：O(nlog₂n)<br>稳定性：不稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#O(n*(log n))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]    <span class="comment">#找到一个基准值</span></span><br><span class="line">        <span class="comment">#遍历整个列表，将小于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; pivot]</span><br><span class="line">        <span class="comment">#遍历整个列表，将大于这个基准值的元素放到一个子列表中</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i&gt;pivot]</span><br><span class="line">        <span class="comment">#首先，明确我们对元素为0个/1个的列表无需要排序</span></span><br><span class="line">        <span class="comment">#使用函数递归</span></span><br><span class="line">        <span class="comment">#目标：让我们在一个基准值的一侧变为有序，然后依次返回，让我们的每个基准值的两侧都变得有序</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less)+[pivot]+quicksort(greater)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这是一些测试样例</span></span><br><span class="line">print(quicksort([<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">11</span>]))</span><br><span class="line">print(quicksort([<span class="number">152</span>,<span class="number">134</span>,<span class="number">38796</span>,<span class="number">7438415</span>,<span class="number">1</span>,<span class="number">2272</span>,<span class="number">34345</span>,<span class="number">24</span>,<span class="number">127</span>]))</span><br></pre></td></tr></table></figure><h2 id="单例："><a href="#单例：" class="headerlink" title="单例："></a>单例：</h2><p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p><p><strong>优点：对唯一实例的受控访问，相当于全局变量，但是又可以防止变量被篡改</strong></p><blockquote><p>通过<strong>new</strong>方法，将类的实例在创建的时候绑定到类属性_inst上。<br>如果cls._inst为None，说明类还未实例化，实例化并将实例绑定到cls._inst，以后每次实例化的时候都返回第一次实例化创建的实例。注意从Singleton派生子类的时候，不要重载<strong>new</strong>。<br>因为类每一次实例化后产生的过程都是通过<strong>new</strong>来控制的，所以通过重载<strong>new</strong>方法，我们 可以很简单的实现单例模式。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">single1 = Single()</span><br><span class="line">single2 = Single()</span><br><span class="line">print(id(single1) , id(single2))</span><br></pre></td></tr></table></figure><h4 id="new-方法"><a href="#new-方法" class="headerlink" title="_ _ new _ _方法:"></a>_ _ new _ _方法:</h4><p>使用类名()创建对象时，Python的解释器首先会调用<strong>new</strong>方法为对象分配空间.<br>_ _ new _ _是一个有object基类提供的内置的静态方法，主要作用有两个：</p><ol><li>在内存中为对象分配空间</li><li>返回对象的引用<br>Python的解释器获得对象的引用后，将引用作为第一个参数，传递给<strong>init</strong>方法。<br>重写<strong>new</strong>方法的代码非常固定。<br>重写<strong>new</strong>方法一定要return super.<strong>new</strong>(cls)，否则Python的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法<br>注意：<strong>new</strong>是一个静态方法，在调用时需要主动传递参数cls<br><strong>new</strong>至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供</li></ol><h2 id="递归斐波那契数列："><a href="#递归斐波那契数列：" class="headerlink" title="递归斐波那契数列："></a>递归斐波那契数列：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fun(i<span class="number">-2</span>) + fei(i<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(fun(i),end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure><h2 id="递归遍历目录："><a href="#递归遍历目录：" class="headerlink" title="递归遍历目录："></a>递归遍历目录：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(p):</span><br><span class="line">        i = os.path.join(p,i)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(i):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fun(i)</span><br><span class="line">            <span class="keyword">if</span> os.path.splitext(i)[<span class="number">1</span>] == <span class="string">'.txt'</span>:</span><br><span class="line">                <span class="keyword">print</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> fun(i)</span><br><span class="line"></span><br><span class="line">path = unicode(<span class="string">r'F:\My Study\linux学习笔记\test'</span>,<span class="string">'utf-8'</span>)   <span class="comment">#需要遍历的目录</span></span><br><span class="line">f(path)</span><br></pre></td></tr></table></figure><h2 id="青蛙跳台阶参考链接："><a href="#青蛙跳台阶参考链接：" class="headerlink" title="青蛙跳台阶参考链接："></a>青蛙跳台阶参考链接：</h2><p><a href="https://blog.csdn.net/Bryce_Liu/article/details/90639516" target="_blank" rel="noopener">https://blog.csdn.net/Bryce_Liu/article/details/90639516</a></p><h2 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h2><p><strong>闭包的定义：</strong></p><ol><li>在一个外函数中定义了一个内函数</li><li>内函数里运用了外函数的临时变量</li><li>并且外函数的返回值是内函数的引用。<br>这样就构成了一个闭包。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        b = a + <span class="number">10</span></span><br><span class="line">        print(<span class="string">"b ="</span>,b)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">outer()()</span><br></pre></td></tr></table></figure><h2 id="装饰器测试程序运行时间："><a href="#装饰器测试程序运行时间：" class="headerlink" title="装饰器测试程序运行时间："></a>装饰器测试程序运行时间：</h2><blockquote><p>使用装饰器测试（1000以内的三个数，相加等于1000的情况，有多少组）这个案例的运行时间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        s_time = time.time() <span class="comment">#获取程序运行的开始时间</span></span><br><span class="line">        fun()    <span class="comment">#运行程序</span></span><br><span class="line">        e_time = time.time() <span class="comment">#获取程序运行的结束时间</span></span><br><span class="line">        <span class="keyword">return</span> e_time-s_time</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="meta">@time_</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1001</span>):</span><br><span class="line">            c = <span class="number">1000</span> - a - b</span><br><span class="line">            <span class="keyword">if</span> a ** <span class="number">2</span> + b ** <span class="number">2</span> == c ** <span class="number">2</span>:</span><br><span class="line">                print(<span class="string">"a = %d , b = %d , c = %d"</span> % (a,b,c)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(func())</span><br></pre></td></tr></table></figure><h2 id="python实现树的遍历："><a href="#python实现树的遍历：" class="headerlink" title="python实现树的遍历："></a>python实现树的遍历：</h2><p>参考链接：<br><a href="https://blog.csdn.net/bone_ace/article/details/46718683" target="_blank" rel="noopener">https://blog.csdn.net/bone_ace/article/details/46718683</a></p><p>广度遍历：层次遍历<br>深度遍历：先、中、后序遍历</p><p>层次遍历：一层一层的遍历<br>先序遍历：依据 根–左–右 的顺序遍历<br>中序遍历：依据 左–根–右 的顺序遍历<br>后序遍历：依据 左–右–根 的顺序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''树的节点'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.lchild = <span class="literal">None</span>  <span class="comment">#左孩子</span></span><br><span class="line">        self.rchild = <span class="literal">None</span>  <span class="comment">#右孩子</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''二叉树'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span>    <span class="comment"># 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">'''添加的方法'''</span></span><br><span class="line">        node = Node(item)   <span class="comment"># 先构造一个节点</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment">#     如果是空树 直接添加元素</span></span><br><span class="line">            self.root = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]  <span class="comment"># 一个队列 用来存放的就是要遍历和处理的元素</span></span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment">#队列只要不为空 就始终能拿出节点进行判断</span></span><br><span class="line">            <span class="comment"># 先从队列中取出一个节点</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 看当前这个节点左边的孩子是否为空 如果是空 直接挂节点</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.lchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不为空则认定左孩子存在 追加到队列</span></span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 查看节点右孩子 与左孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                cur_node.rchild = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breadth_trvael</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''层次遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = [self.root]</span><br><span class="line">        <span class="keyword">while</span> queue:    <span class="comment"># 只要队列不为空就一直取元素</span></span><br><span class="line">            cur_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            print(cur_node.elem,end=<span class="string">' '</span>)</span><br><span class="line">            <span class="comment"># 如果左孩子存在 添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.lchild:</span><br><span class="line">                queue.append(cur_node.lchild)</span><br><span class="line">            <span class="comment"># 右孩子同理</span></span><br><span class="line">            <span class="keyword">if</span> cur_node.rchild:</span><br><span class="line">                queue.append(cur_node.rchild)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, node)</span>:</span>   <span class="comment">#传一个根节点</span></span><br><span class="line">        <span class="string">'''先序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:    <span class="comment">#递归的终结条件</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(node.elem,end=<span class="string">' '</span>)    <span class="comment">#先打印根</span></span><br><span class="line">        self.preorder(node.lchild)  <span class="comment">#处理左半部分</span></span><br><span class="line">        self.preorder(node.rchild)  <span class="comment">#处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''中序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment">#输出根</span></span><br><span class="line">        self.inorder(node.rchild)  <span class="comment">#再处理右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">'''后序遍历'''</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorder(node.lchild)  <span class="comment"># 先处理左部分</span></span><br><span class="line">        self.postorder(node.rchild)  <span class="comment"># 然后处理右半部分</span></span><br><span class="line">        print(node.elem, end=<span class="string">' '</span>)   <span class="comment"># 最后输出根</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tree = Tree()</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    tree.add(<span class="number">0</span>)</span><br><span class="line">    tree.add(<span class="number">1</span>)</span><br><span class="line">    tree.add(<span class="number">2</span>)</span><br><span class="line">    tree.add(<span class="number">3</span>)</span><br><span class="line">    tree.add(<span class="number">4</span>)</span><br><span class="line">    tree.add(<span class="number">5</span>)</span><br><span class="line">    tree.add(<span class="number">6</span>)</span><br><span class="line">    tree.add(<span class="number">7</span>)</span><br><span class="line">    tree.add(<span class="number">8</span>)</span><br><span class="line">    tree.add(<span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'层次遍历：'</span>)</span><br><span class="line">    tree.breadth_trvael()</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'先序遍历：'</span>)</span><br><span class="line">    tree.preorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'中序遍历：'</span>)</span><br><span class="line">    tree.inorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'后序遍历：'</span>)</span><br><span class="line">    tree.postorder(tree.root)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><p>参考链接：<br><a href="https://www.jianshu.com/p/9f2aca048c84" target="_blank" rel="noopener">https://www.jianshu.com/p/9f2aca048c84</a><br><a href="https://www.jb51.net/article/133798.htm" target="_blank" rel="noopener">https://www.jb51.net/article/133798.htm</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''节点类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''单链表'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node=None)</span>:</span></span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''判断链表是否为空'''</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="literal">None</span>    <span class="comment">#如果头节点为空 列表就为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''链表长度'''</span></span><br><span class="line">        cur = self.head <span class="comment">#cur游标 用来移动遍历节点</span></span><br><span class="line">        count = <span class="number">0</span>        <span class="comment">#记录数量</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next    <span class="comment">#移动游标</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''遍历整个链表'''</span></span><br><span class="line">        cur = self.head <span class="comment">#代表第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''在链表头部添加元素，头插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self.head   <span class="comment"># 新元素的下一个节点指向链表第一个元素</span></span><br><span class="line">        self.head = node    <span class="comment">#头节点指向新元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''向链表的尾部添加元素,尾插法'''</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty(): <span class="comment">#如果链表为空</span></span><br><span class="line">            self.head = node    <span class="comment">#头节点指向添加的元素</span></span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment">#不为空</span></span><br><span class="line">            cur = self.head     <span class="comment"># 游标</span></span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>: <span class="comment"># 游标下一个位置不为空开始进入循环 为空则不进入循环</span></span><br><span class="line">                cur = cur.next  <span class="comment"># 游标移动</span></span><br><span class="line">            cur.next = node <span class="comment">#当游标下一位置为空时添加元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span>    <span class="comment"># 传入一个插入位置pos 一个插入元素item</span></span><br><span class="line">        <span class="string">'''指定位置添加元素'''</span></span><br><span class="line">        <span class="comment"># 如果添加位置在头部 直接使用头插入方法</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span> :</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):   <span class="comment">#插入位置超出列表范围 使用尾插法</span></span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 当循环退出后cur指向 pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''删除元素,根据具体的数据删除'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="literal">None</span>    <span class="comment"># 前一位置</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断子节点是否为头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.head:</span><br><span class="line">                    self.head = cur.next <span class="comment"># 直接改变头指针指向的地址</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cur.next <span class="comment"># 如果删除尾部 cur.next刚好指向none</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">'''查找节点是否存在'''</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:  <span class="comment"># 列表不为空时</span></span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    ll.append(<span class="number">2</span>)    <span class="comment">#尾部添加</span></span><br><span class="line">    ll.append(<span class="number">6</span>)</span><br><span class="line">    ll.add(<span class="number">8</span>)   <span class="comment">#头部添加</span></span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.insert(<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'开始遍历链表元素：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="comment"># 删除一个元素</span></span><br><span class="line">    ll.remove(<span class="number">6</span>)</span><br><span class="line">    print(<span class="string">'删除后遍历：'</span>)</span><br><span class="line">    ll.travel()</span><br><span class="line">    print(<span class="string">'是否为空:'</span>,ll.is_empty())</span><br><span class="line">    print(<span class="string">'链表长度：'</span>,ll.length())</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">10</span>))</span><br><span class="line">    print(<span class="string">'元素是否存在：'</span>,ll.search(<span class="number">9</span>))</span><br></pre></td></tr></table></figure><h2 id="栈与队列："><a href="#栈与队列：" class="headerlink" title="栈与队列："></a>栈与队列：</h2><p>参考链接：<br><a href="https://blog.csdn.net/yushupan/article/details/82312819" target="_blank" rel="noopener">https://blog.csdn.net/yushupan/article/details/82312819</a><br><a href="https://www.jianshu.com/p/1327cc0de255" target="_blank" rel="noopener">https://www.jianshu.com/p/1327cc0de255</a></p><p><strong>栈和队列是两种基本的数据结构，同为容器类型。</strong></p><ul><li>两者根本的区别在于： </li><li>栈stack:后进先出</li><li>队列queue:先进先出</li></ul><h4 id="栈的构造："><a href="#栈的构造：" class="headerlink" title="栈的构造："></a>栈的构造：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Stack() 创建一个新的空栈</span></span><br><span class="line"><span class="string">push(item) 添加一个新的元素item到栈顶</span></span><br><span class="line"><span class="string">pop() 弹出栈顶元素</span></span><br><span class="line"><span class="string">peek() 返回栈顶元素</span></span><br><span class="line"><span class="string">is_empty() 判断栈是否为空</span></span><br><span class="line"><span class="string">size() 返回栈的元素个数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""栈类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空栈"""</span></span><br><span class="line">        self.stack = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""添加一个新的元素到栈顶"""</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""弹出栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断栈是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈元素的个数"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    print(s.is_empty())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">6</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    print(s.stack)</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(s.is_empty())</span><br><span class="line">    print(s.size())</span><br></pre></td></tr></table></figure><h4 id="队列的构造："><a href="#队列的构造：" class="headerlink" title="队列的构造："></a>队列的构造：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Queue() 创建一个空的队列</span></span><br><span class="line"><span class="string">enqueue(item) 往队列中添加一个item元素</span></span><br><span class="line"><span class="string">dequeue() 从队列头部删除一个元素</span></span><br><span class="line"><span class="string">is_empty() 判断一个队列是否为空</span></span><br><span class="line"><span class="string">size() 返回队列的大小</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个空队列"""</span></span><br><span class="line">        self.queue = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""往队列中添加一个元素"""</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队列头部删除一个元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ie_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断一个队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue == []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line">    q.enqueue(<span class="number">6</span>)</span><br><span class="line">    q.enqueue(<span class="number">7</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.size())</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">    print(q.dequeue())</span><br><span class="line">    print(q.ie_empty())</span><br><span class="line">    print(q.size())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
